<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>.grad - y2k 科技系音乐制作人</title>
    <style>
      :root {
        --sky-top: #5aa8ff;
        --sky-mid: #7fc0ff;
        --sky-bot: #cbe4ff;
        --text: #eaf3ff;
        --accent: #9dd1ff;
        --grid: rgba(255, 255, 255, 0.05);
      }

      *, *::before, *::after { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        color: var(--text);
        font-family: Bahnschrift, "Segoe UI", Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;
        background: #6fb4ff;
        overflow: hidden;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .stage {
        position: fixed;
        inset: 0;
        z-index: 0;
      }
      #sky {
        width: 100%;
        height: 100%;
        display: block;
      }

      .grid {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 1;
        background-image:
          repeating-linear-gradient(
            to right,
            var(--grid) 0,
            var(--grid) 1px,
            transparent 1px,
            transparent 16px
          ),
          repeating-linear-gradient(
            to bottom,
            var(--grid) 0,
            var(--grid) 1px,
            transparent 1px,
            transparent 16px
          );
        background-size: 16px 100%, 100% 16px;
        mix-blend-mode: overlay;
        opacity: 0.7;
        animation: gridShift 16s linear infinite;
      }
      @keyframes gridShift {
        0%   { background-position: 0 0, 0 0; }
        100% { background-position: 16px 16px, 16px 16px; }
      }

      .clouds {
        position: fixed;
        inset: 0;
        z-index: 2;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .cloud-wrap {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .cloud-fallback {
        font-family: "JetBrains Mono", "Cascadia Mono", Consolas, "SFMono-Regular", Menlo, Monaco, monospace;
        letter-spacing: 0.18em;
        font-size: clamp(13px, 2.3vw, 18px);
        text-transform: uppercase;
        color: rgba(220, 245, 255, 0.72);
        text-align: center;
      }

      .hud {
        position: fixed;
        inset: 0;
        z-index: 3;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        font-family: "Segoe UI", Roboto, Ubuntu, sans-serif;
        color: rgba(220, 245, 255, 0.82);
        mix-blend-mode: screen;
      }
      .hud-row {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 3vh 4vw;
        text-transform: uppercase;
        letter-spacing: 0.22em;
        font-size: clamp(9px, 1.2vw, 13px);
      }
      .hud-corner {
        position: relative;
        padding-left: 1.6em;
        display: flex;
        flex-direction: column;
        gap: 0.25em;
      }
      .hud-corner::before,
      .hud-corner::after {
        content: "";
        position: absolute;
        left: 0;
        width: 0.9em;
        height: 1px;
        background: linear-gradient(90deg, rgba(70, 180, 255, 0.45), rgba(0, 0, 0, 0));
      }
      .hud-corner::before { top: 0.35em; }
      .hud-corner::after  { top: 1em; }
      .hud-label {
        font-size: 0.78em;
        opacity: 0.55;
        letter-spacing: 0.32em;
      }
      .hud-value {
        font-weight: 600;
        letter-spacing: 0.42em;
      }
      .hud-clock {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.4em;
      }
      .hud-clock::after {
        content: "";
        width: 4.6em;
        height: 1px;
        background: linear-gradient(90deg, rgba(0, 0, 0, 0), rgba(120, 220, 255, 0.6));
      }
      .hud-row-bottom { align-items: flex-end; }
      .hud-meter {
        display: flex;
        flex-direction: column;
        gap: 0.55em;
        max-width: 20rem;
      }
      .hud-meter-label {
        font-size: 0.72em;
        opacity: 0.5;
        letter-spacing: 0.36em;
      }
      .hud-meter-track {
        position: relative;
        height: 4px;
        background: rgba(120, 180, 255, 0.18);
        border-radius: 999px;
        overflow: hidden;
      }
      .hud-meter-fill {
        position: absolute;
        inset: 0;
        width: 70%;
        background: linear-gradient(90deg, rgba(60, 190, 255, 0.35), rgba(210, 245, 255, 0.85));
      }
      .hud-dots {
        display: grid;
        grid-auto-flow: column;
        gap: 0.65em;
      }
      .hud-dots span {
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: rgba(150, 225, 255, 0.5);
        box-shadow: 0 0 6px rgba(100, 200, 255, 0.4);
      }

      .main {
        position: relative;
        z-index: 2;
        min-height: 100dvh;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        text-align: center;
        padding: 1vh 1vw 0;
      }
      .brand {
        font-weight: 500;
        letter-spacing: 0.16em;
        color: #f5f7ff;
        text-shadow: 0 0 12px rgba(15, 45, 85, 0.35);
        user-select: none;
        font-size: clamp(28px, 6vw, 54px);
        font-family: "VT323", "Fira Code", "IBM Plex Mono", "Lucida Console", "Consolas", monospace;
        background: none;
        padding: 0;
        border: none;
        box-shadow: none;
        text-transform: none;
      }
      .brand .dot { color: inherit; }
      .brand .grad { opacity: 1; }

      @media (prefers-reduced-motion: reduce) {
        .grid { animation: none; }
      }
    </style>
  </head>
  <body>
    <div class="stage">
      <canvas id="sky" aria-hidden="true"></canvas>
    </div>
    <div class="grid" aria-hidden="true"></div>
    <div class="clouds" aria-hidden="true">
      <div class="cloud-wrap" id="ascii-root">
        <div class="cloud-fallback">Loading ASCII effect…</div>
      </div>
      </div>
    </div>
    <div class="hud" aria-hidden="true">
      <div class="hud-row">
        <div class="hud-corner">
          <span class="hud-label">.grad // system</span>
          <span class="hud-value">live</span>
        </div>
        <div class="hud-clock">
          <span class="hud-label">signal</span>
          <span class="hud-value">∞.221hz</span>
        </div>
      </div>
      <div class="hud-row hud-row-bottom">
        <div class="hud-meter">
          <span class="hud-meter-label">vector gain</span>
          <div class="hud-meter-track"><span class="hud-meter-fill"></span></div>
        </div>
        <div class="hud-dots">
          <span></span><span></span><span></span><span></span>
        </div>
      </div>
    </div>

    <main class="main">
      <h1 class="brand" aria-label=".grad">
        <span class="dot">.</span><span class="grad">grad</span>
      </h1>
    </main>

    <script>
      (function () {
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const canvas = document.getElementById('sky');
        const ctx = canvas.getContext('2d');

        function draw() {
          const styles = getComputedStyle(document.documentElement);
          const w = Math.floor(window.innerWidth * dpr);
          const h = Math.floor(window.innerHeight * dpr);
          canvas.width = w;
          canvas.height = h;
          canvas.style.width = window.innerWidth + 'px';
          canvas.style.height = window.innerHeight + 'px';

          const gradient = ctx.createLinearGradient(0, 0, 0, h);
          gradient.addColorStop(0, styles.getPropertyValue('--sky-top').trim());
          gradient.addColorStop(0.55, styles.getPropertyValue('--sky-mid').trim());
          gradient.addColorStop(1, styles.getPropertyValue('--sky-bot').trim());
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, w, h);
        }

        draw();
        window.addEventListener('resize', draw);
        window.addEventListener('orientationchange', draw);
      })();
    </script>

    <script src="cloud-data0.js"></script>
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";
      import { AsciiEffect } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/effects/AsciiEffect.js";

      const wrapper = document.getElementById('ascii-root');
      const asciiCharacters = '                              .:-=+*#%@$';
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)');
      const base64 = window.__CLOUD_GIF_BASE64__;

      if (!base64) {
        wrapper.innerHTML = '<div class="cloud-fallback">缺少 GIF 数据</div>';
        throw new Error('Missing GIF base64 data');
      }

      function base64ToArrayBuffer(str) {
        const clean = str.replace(/\s+/g, '');
        const binary = atob(clean);
        const len = binary.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
        return bytes.buffer;
      }

      function parseGIF(arrayBuffer) {
        const bytes = new Uint8Array(arrayBuffer);
        const stream = {
          data: bytes,
          pos: 0,
          readByte() { return this.data[this.pos++]; },
          readBytes(count) { const slice = this.data.subarray(this.pos, this.pos + count); this.pos += count; return slice; },
          readUnsigned() { const value = this.data[this.pos] | (this.data[this.pos + 1] << 8); this.pos += 2; return value; },
          readString(length) { let out = ''; for (let i = 0; i < length; i++) out += String.fromCharCode(this.readByte()); return out; }
        };

        function readColorTable(size) {
          const table = new Array(size);
          for (let i = 0; i < size; i++) {
            const r = stream.readByte();
            const g = stream.readByte();
            const b = stream.readByte();
            table[i] = [r, g, b, 255];
          }
          return table;
        }

        function skipSubBlocks() {
          let size = stream.readByte();
          while (size !== 0) { stream.pos += size; size = stream.readByte(); }
        }

        function readSubBlocks() {
          const chunks = [];
          let length = 0;
          let size = stream.readByte();
          while (size !== 0) { const chunk = stream.readBytes(size); chunks.push(chunk); length += chunk.length; size = stream.readByte(); }
          const data = new Uint8Array(length);
          let offset = 0;
          for (const chunk of chunks) { data.set(chunk, offset); offset += chunk.length; }
          return data;
        }

        function lzwDecode(minCodeSize, data, pixelCount) {
          let pos = 0;
          const clearCode = 1 << minCodeSize;
          const eoiCode = clearCode + 1;
          let codeSize = minCodeSize + 1;
          let dictionary = [];
          let dictLength = 0;
          const output = new Array(pixelCount);

          function resetDictionary() {
            dictionary = new Array(4096);
            const size = 1 << minCodeSize;
            for (let i = 0; i < size; i++) dictionary[i] = [i];
            dictionary[clearCode] = [];
            dictionary[eoiCode] = null;
            dictLength = eoiCode + 1;
          }

          resetDictionary();

          let dataVal = 0;
          let dataBits = 0;

          function readCode() {
            while (dataBits < codeSize) {
              if (pos >= data.length) return null;
              dataVal |= data[pos++] << dataBits;
              dataBits += 8;
            }
            const code = dataVal & ((1 << codeSize) - 1);
            dataVal >>= codeSize;
            dataBits -= codeSize;
            return code;
          }

          let code;
          let prev = null;
          let outPos = 0;

          while ((code = readCode()) !== null) {
            if (code === clearCode) { resetDictionary(); codeSize = minCodeSize + 1; prev = null; continue; }
            if (code === eoiCode) break;

            let entry;
            if (dictionary[code]) { entry = dictionary[code].slice(); }
            else if (code === dictLength && prev) { entry = prev.concat(prev[0]); }
            else { break; }

            for (let i = 0; i < entry.length && outPos < pixelCount; i++) output[outPos++] = entry[i];

            if (prev && dictLength < 4096) dictionary[dictLength++] = prev.concat(entry[0]);
            prev = entry;

            if (dictLength === (1 << codeSize) && codeSize < 12) codeSize++;
          }

          return output.slice(0, outPos);
        }

        function deinterlace(pixels, width) {
          const height = Math.floor(pixels.length / width);
          const newPixels = new Array(pixels.length);
          const passes = [
            { start: 0, step: 8 },
            { start: 4, step: 8 },
            { start: 2, step: 4 },
            { start: 1, step: 2 }
          ];
          let pos = 0;
          passes.forEach(pass => {
            for (let y = pass.start; y < height; y += pass.step) {
              const offset = y * width;
              for (let x = 0; x < width; x++) { if (pos < pixels.length) newPixels[offset + x] = pixels[pos++]; }
            }
          });
          return newPixels;
        }

        const header = stream.readString(6);
        if (header !== 'GIF87a' && header !== 'GIF89a') throw new Error('Invalid GIF signature');

        const width = stream.readUnsigned();
        const height = stream.readUnsigned();
        const packed = stream.readByte();
        const gctFlag = (packed & 0x80) !== 0;
        const gctSize = 1 << ((packed & 0x07) + 1);
        const backgroundColorIndex = stream.readByte();
        stream.readByte();

        let globalColorTable = null;
        if (gctFlag) globalColorTable = readColorTable(gctSize);

        const frames = [];
        let gce = { delay: 10, transparencyIndex: null, disposalType: 0 };

        while (stream.pos < stream.data.length) {
          const blockId = stream.readByte();
          if (blockId === 0x3B) {
            break;
          } else if (blockId === 0x21) {
            const label = stream.readByte();
            if (label === 0xF9) {
              const blockSize = stream.readByte();
              const gPacked = stream.readByte();
              const delay = stream.readUnsigned();
              const transpIndex = stream.readByte();
              stream.readByte();
              gce = {
                disposalType: (gPacked >> 2) & 0x07,
                transparencyIndex: (gPacked & 0x01) ? transpIndex : null,
                delay: delay === 0 ? 10 : delay,
              };
              if (blockSize !== 4) stream.pos += blockSize - 4;
            } else if (label === 0xFF) {
              const blockSize = stream.readByte();
              stream.pos += blockSize;
              skipSubBlocks();
            } else {
              skipSubBlocks();
            }
          } else if (blockId === 0x2C) {
            const left = stream.readUnsigned();
            const top = stream.readUnsigned();
            const frameWidth = stream.readUnsigned();
            const frameHeight = stream.readUnsigned();
            const iPacked = stream.readByte();
            const lctFlag = (iPacked & 0x80) !== 0;
            const interlaced = (iPacked & 0x40) !== 0;
            const lctSize = 1 << ((iPacked & 0x07) + 1);

            let colorTable = globalColorTable;
            if (lctFlag) colorTable = readColorTable(lctSize);

            const lzwMinCodeSize = stream.readByte();
            const imageData = readSubBlocks();
            const pixelCount = frameWidth * frameHeight;
            let pixelIndices = lzwDecode(lzwMinCodeSize, imageData, pixelCount);
            if (interlaced) pixelIndices = deinterlace(pixelIndices, frameWidth);

            const patch = new Uint8ClampedArray(frameWidth * frameHeight * 4);
            const transIndex = gce.transparencyIndex;
            for (let i = 0; i < frameWidth * frameHeight; i++) {
              const colorIndex = pixelIndices[i];
              const offset = i * 4;
              if (colorIndex === transIndex) {
                patch[offset] = 0;
                patch[offset + 1] = 0;
                patch[offset + 2] = 0;
                patch[offset + 3] = 0;
              } else {
                const color = colorTable[colorIndex] || [0, 0, 0, 0];
                patch[offset] = color[0];
                patch[offset + 1] = color[1];
                patch[offset + 2] = color[2];
                patch[offset + 3] = color[3];
              }
            }

            frames.push({
              dims: { left, top, width: frameWidth, height: frameHeight },
              delay: gce.delay,
              disposalType: gce.disposalType,
              patch,
            });

            gce = { delay: 10, transparencyIndex: null, disposalType: 0 };
          } else {
            break;
          }
        }

        const backgroundColor = globalColorTable && globalColorTable[backgroundColorIndex]
          ? globalColorTable[backgroundColorIndex].slice()
          : [0, 0, 0, 0];

        return {
          lsd: { width, height, backgroundColor },
          frames,
        };
      }

      function buildFrameSequence(frames, width, height, backgroundColor) {
        const total = width * height * 4;
        const background = new Uint8ClampedArray(total);
        if (backgroundColor) {
          for (let i = 0; i < total; i += 4) {
            background[i] = backgroundColor[0];
            background[i + 1] = backgroundColor[1];
            background[i + 2] = backgroundColor[2];
            background[i + 3] = backgroundColor[3];
          }
        }

        const current = new Uint8ClampedArray(background);
        const sequence = [];

        frames.forEach((frame, index) => {
          const working = current.slice();
          const { left, top, width: fw, height: fh } = frame.dims;
          const patch = frame.patch;

          for (let y = 0; y < fh; y++) {
            for (let x = 0; x < fw; x++) {
              const srcIdx = (y * fw + x) * 4;
              const destIdx = ((top + y) * width + (left + x)) * 4;
              const alpha = patch[srcIdx + 3];
              if (alpha === 0) continue;
              working[destIdx] = patch[srcIdx];
              working[destIdx + 1] = patch[srcIdx + 1];
              working[destIdx + 2] = patch[srcIdx + 2];
              working[destIdx + 3] = alpha;
            }
          }

          const delay = Math.max(40, (frame.delay || 10) * 10);
          sequence.push({ pixels: working.slice(0), delay, disposalType: frame.disposalType, dims: frame.dims });

          current.set(working);

          if (frame.disposalType === 2) {
            const { left, top, width: fw2, height: fh2 } = frame.dims;
            for (let y = 0; y < fh2; y++) {
              for (let x = 0; x < fw2; x++) {
                const idx = ((top + y) * width + (left + x)) * 4;
                current[idx] = background[idx];
                current[idx + 1] = background[idx + 1];
                current[idx + 2] = background[idx + 2];
                current[idx + 3] = background[idx + 3];
              }
            }
          } else if (frame.disposalType === 3 && sequence[index - 1]) {
            current.set(sequence[index - 1].pixels);
          }
        });

        return sequence;
      }

      const arrayBuffer = base64ToArrayBuffer(base64);
      const gif = parseGIF(arrayBuffer);
      const frames = buildFrameSequence(gif.frames, gif.lsd.width, gif.lsd.height, gif.lsd.backgroundColor);

      const frameCanvas = document.createElement('canvas');
      frameCanvas.width = gif.lsd.width;
      frameCanvas.height = gif.lsd.height;
      const frameCtx = frameCanvas.getContext('2d');
      const frameImage = frameCtx.createImageData(gif.lsd.width, gif.lsd.height);
      const texture = new THREE.CanvasTexture(frameCanvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = false;

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const effect = new AsciiEffect(renderer, asciiCharacters, { invert: true, resolution: 0.20 });
      effect.domElement.style.position = 'absolute';
      effect.domElement.style.left = '0';
      effect.domElement.style.top = '0';
      effect.domElement.style.width = '100%';
      effect.domElement.style.height = '100%';
      effect.domElement.style.color = '#e9f3ff';
      effect.domElement.style.backgroundColor = 'transparent';
      effect.domElement.style.mixBlendMode = 'screen';
      effect.domElement.style.pointerEvents = 'none';

      wrapper.innerHTML = '';
      wrapper.style.position = 'relative';
      wrapper.appendChild(effect.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(2, 2),
        new THREE.MeshBasicMaterial({ map: texture, transparent: true, toneMapped: false, depthTest: false })
      );
      scene.add(plane);

      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
      camera.position.set(0, 0, 2);
      camera.lookAt(0, 0, 0);

      function applySize() {
        const rect = wrapper.getBoundingClientRect();
        const width = rect.width || window.innerWidth;
        const height = rect.height || window.innerHeight;
        renderer.setSize(width, height);
        effect.setSize(width, height);

        const displayAspect = width / height;
        const gifAspect = gif.lsd.width / gif.lsd.height;
        if (gifAspect > displayAspect) {
          plane.scale.set(gifAspect / displayAspect, 1, 1);
        } else {
          plane.scale.set(1, displayAspect / gifAspect, 1);
        }
      }

      const resizeObserver = new ResizeObserver(applySize);
      resizeObserver.observe(wrapper);
      window.addEventListener('resize', applySize);
      applySize();

      let frameIndex = 0;
      let nextFrameAt = performance.now();

      function drawFrame(index) {
        const frame = frames[index];
        frameImage.data.set(frame.pixels);
        frameCtx.putImageData(frameImage, 0, 0);
        texture.needsUpdate = true;
      }

      function render(time) {
        if (frames.length) {
          if (time >= nextFrameAt) {
            drawFrame(frameIndex);
            nextFrameAt = time + frames[frameIndex].delay;
            frameIndex = (frameIndex + 1) % frames.length;
          }
        }

        effect.render(scene, camera);
        if (!prefersReduced.matches) {
          requestAnimationFrame(render);
        }
      }

      if (prefersReduced.matches) {
        drawFrame(0);
        effect.render(scene, camera);
      } else {
        requestAnimationFrame(render);
      }

      try { delete window.__CLOUD_GIF_BASE64__; } catch (err) {}
    </script>
  </body>
</html>

